package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {
	
		/*
		1. 상속(is a : ~은 ~이다) ex.차의 공통속성을 이용하여 앰블런스, 택시, 버스 등을 만들수 있음
		-기존의 클래스를 재사용하여 새로운 클래스를 작성
		-적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		-새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써주기만 하면된다.
		
		class Child extends Parent{
		....
		}
		-상속해주는 클래스를 '조상클래스', 상속받는 클래스 '자손클래스'
		:조상클래스 - 부모클래스, 상위클래스, 기반클래스
		:자손클래스 - 자식클래스, 하위클래스, 파생된클래스
		
		- 멤버만 상속이 된다. 
		-멤버변수(클래스변수, 인스턴스변수), 메서드(클래스메서드, 인스턴스메서드)
		-자손클래스의 멤버의 개수는 조상클래스보다 같거나 많다.
		(같으면 의미가없다)
		2. 포함(has a : ~은 ~을 포함하고 있다.)
		ex/낮은단계가 큰단계를 어떻게 하고 있나
		 -상속이외에 클래스를 재사용하는 방법
		 -한 클래스의 멤버변수로 다른 클래스를 선언하는 방법
		3.단일상속
		 -자바에서는 단일상속(두개이상은 불가능)만 가능하다.(한번에 여러개는 불가능, 단계적으로 상속)
		 class TVCR extends TV, VCR{//불가능
		 -TV와 VCR에 동일한 멤버가 있을때 어떤것을 상속받을지 알수없다.
		 -VCR의 멤버명을 바꾼다면 그동안 VCR의 멤버를 사용하던 부분들을 모두 수정해주어야한다.
		 -그래서 단일상속만 사용
		 -클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있다.
		4. Object클래스(모든 클래스의 조상)
		 -모든 클래스의 상속 계층도의 가장위에 위치하는 조상클래스이다.
		 -다른 클래스로부터 상속받지 않는 클래스들은 자동적으로object클래스를 상속받음
		 -toString()나 equals()와 같은 메서드를 따로 정의하지 않고 사용할수 있는것은
		 Object클래스에 정의된 것들이기 때문.
		 class Tv{
		 }
		 =>컴파일후 
		 class Tv extends Object{
		 Tv()
		 
		 }
		5.오버라이드(Override)
		 -조상클래스로부터 상속받은 메서드의 내용을 변경(재정의)하는것.
		 -오버라이드에서 선언하면 자식내용이 먼저.
		 -오버라이드 되기 위한 조건 => 선언부가 일치해야 한다.
		 :자손클래스에서 오버라이드하는 메서드는 조상클래스의 매서드의 명과 동일해야 한다.
		 :매개변수의 타입과 개수가 같아야한다.
		 :접근제어자를 조상 클래스보다 좁은 범위로 설정할 수 없다.
		 :예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		 :리턴타입이 같아야한다.
		 
		 
		 String toString()선언부 {
		  구현부
		 }
		
		 6.super.
		  - 조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을때 서로 구분하기 위해 사용
		  - this는 지역변수와 전역변수 구분, super는 조상클래스 멤버와 자손클래스의 멤버 구분
		  -조상멤버와 자신의 멤버를 구별하는데 사용한다는 것을 제외하고는 this.과 근복적으로 동일
		  -static메서드에서 사용할 수 없다.
		 7.super() - 조상클래스의 생성자를 호출
		  -this()와 마찬가지로 super()역시 생성자이다.
		  -this()는 같은 클래스의 다른 생성자를 호출
		   super()는 부모클래스의 생성자를 호출
		  -생성자의 첫줄에는 조상클래스의 생성자를 호출해야 한다.
		   자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있음으로 조상의 멤버들이 먼저 초기화 되어야한다.
		  -생성할때는 부모먼저, 호출할때는 자식먼저
	
		 *호출할때*
		 변수: 지역->전역>부모
		 메서드: 자식-> 부모
		 
		8.제어자
		 -클래스 변수 메서드의 선언부에 사용된다.
		 -접근제어자와 그외 제어자로 구분
		 -접근제어자 :private, default, protected, public(같은 프로젝트 내에서 어디서든) 
		 -그외제어자 :static, final, abstract, native....
		 -접근제어자 그외제어자 1씩 같이 사용 할 수 있음
		 -접근제어자를 제일 왼쪽(그외제어도 제일 왼쪽에 올수잇음)
		 -static(클래스의, 공통적인)
		  :멤버변수, 메서드, 초기화블럭에 사용
		  :static변수
		  	->모든 인스턴스에서 공통적으로 사용
		  	->인스턴스를 생성하지 않고도 호출 가능
		  	->클래스가 메모리에 로드될때 생성
		  :static메서드
		  	->인스턴스 생성없이 사용 가능
		  	->클래스메서드 내에서 인스턴스 멤버를 호출할 수 없다.
		 -final(마지막의, 변경할 수 없는)
		 	:변수에 사용시 변경할 수 없는 상수가 됨
		 	:메서드에 사용시 오버라이드가 안됨(메서드에 할시 클래스상속은 되지만 오버라이드가 안됨)
		 	:클래스에 사용시 상속할 수 없는 클래스가 된다(조상클래스가 될 수 없다)
		 	
		 -abstract(추상의, 미완성된)
		 	:메서드와 클래스에만 사용가능
		 	:메서드에 사용시 구현부는 작성하지 않는다
		 		void method();
		 9.접근제어자
		  -private: 같은 클래스내에서 접근가능
		  -default:패키지내에서만 가능, 클래스명 아무것도 안쓰거나 변수명 앞에 아무것도 안쓰거나 기본으로 생성되어있음 안보일뿐-
		  -protected: 같은패키지+다른패키지의 자손 클래스에서 접근 가능
		  -public : 접근제한이 없다
		  
		 10. 캡슐화 
		  -접근제어자를 사용하는 이유
		   :외부로부터 데이터를 보호하기 위한 목적
		   :외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해 사용
		  
		 11.다형성(polymorphism)  
		  -여러가지 형태를 가질 수 있는 능력,하나의 묶음으로 만들려고
		  - 한타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
		  	car c = new firecar();
		  	car c = new ambulance();
		  -부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		  -상속이 기본이야
		  
		 12. 참조변수의 형변환(상속)
		  -서로 상속관계에 있는 클래스에서만 형변환이 가능
		  - 자손타입 -> 부모타입으로 대입 : 형변환 생략 가능 up_casting
		  - 부모타입 ->자손타입으로 대입 : 형변환 생략 불가  down_casting
		 
		 13. instanceof
		  - 캐스팅 가능 판단여부
		  - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용
		  - 연산결과가 boolean
		  - 연산결과가 true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		  - 클래스메서드와 클래스 변수는 참조변수의 타입에 영향을 받는다. 
		  - SmarTv t = new SmarTv에선 부모클래스의 클래스변수(메서드)를 쓸수있다.(본인클래스에 없으면 부모테이블에서 찾아서씀)
		  - Tv t = new SmarTv에선 부모클래스의 클래스변수(메서드)를 쓸수없다.쓸려면 casting해야함
		  
		  -참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드뿐이다.(인스턴스 변수x)
		   
		 14. 매개변수의 다형성
		  -참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
		 
		 15.여러객체 배열, Vector
		   -조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다. - 다형성
		   -Vector
		   	: 배열을 사용할 경우 전체 크기를 한번 정하면 변경할 수 없다.
		   	  이를 Vector클래스를 이용하여 해결할 수 있다.
		   	: 동적으로 크기가 관리되는 객체배열 이라고 할 수 있다.
		   	:방을 지정해서 넣을수 없다. 자동적으로 얼마나 방이 생성되었는지 모르기에
		   	
		   	Vector v = new Vector();
		   	Vector() : 10개의 객체를 저장할 수 있는 Vector인스턴스를 생성한다.자동적으로 10개씩 생성
		   	add() : Vector에 객체를 추가한다.순차적으로 방에 값이 추가
		   	remove() : Vector에 객체를 삭제한다.
		   	isEmpty(): Vector에 객체를 가지고 있는지 확인 비어있으면 true
		   	Object get(int index): 몇번방의 값을 읽어오는것. index번째 객체를 반환한다. 반환타입은 Object
		   	int size() : Vector에 객체가 저장된 개수를 반환
		  
		 16.추상메서드 abstract class(추상메서드를 한개라도 가지고 있는 클래스를 추상클래스라고 부름)
		 	-미완성된 클래스, : 미완성된 메서드를 가지고 있다는 의미
		 	-구성
		 	 	 abstract class 클래스명{
		 	 	}
		 	 	
		   -추상메서드
		   	:선언부와 구현부로 구성되어있다.
		   	:추상 메서드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메서드를 의미한다.
		   		
		   		abstract 리턴타입 메서드명();
		   -추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 클래스의 추상메서드를 구현해 주면된다.
		   
		  17.인터페이스(분석설계 마지막에 생성)
		   -일종의 추상클래스이지만 추상메서드와 상수만을 멤버로 가진다.
		   -인터페이스의 작성
		   	interface 인터페이스명{
		   		public static final 변수타입 변수명 = 값;
		   		public abstract 반환타입 메서드명(매개변수타입 명,...);
		   		
		   	}
			-생성자는 인스턴스화가 안되어서 인터페이스 안에선 생성이 안됨
			-모든 멤버변수는 public static final 이어야 한다.=> 생략가능
			-모든 메서드는 public abstract이어야 한다. => 생략가능	
			-인터페이스의 상속
			 :인터페이스끼리만 상속이 가능
			 	=>구현된 메서드를 상속받으면 더이상 인터페이스가 아니게 된다.
			 :인터페이스는 다중상속 가능
			  	=>어차피 구현이 안되어있으니 같은 이름의 메서드가 있어도 어떤걸 써든 괜찮음
			 :Object와 같은 최고 조상은 없다.
			
			-인터페이스의 구현
			 :추상메서드의 구현 
			 :자체로는 인스턴스를 생성할 수 없다.
			 :자신이 정의된 추상메서드의 몸통을 만들어 주는 클래스를 작성해야 한다.
			 :클래스의 확장(extends),인터페이스의 구현(implements)
			 :인터페이스의 move메서드를 만들때 메서드의 이름을
			 	:IMove => IMoveImpl
			 	
			-인터페이스의 다형성
			 :인터페이스타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
			 
			-인터페이스의 장점
			 :개발시간을 단축
			 :표준화가 가능
			 :서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
			 :독립적인 프로그래밍이 가능하다.
			 :7-26예제 꼭해보기!!!!!!!!!!!!!7장에 관한 내용을 거의 다 담고있음
			 
			-인터페이스의 이해
			 :클래스를 사용한 쪽(user)과 클래스를 제공하는 쪽(provider)이 있다.
			 A(제공)-->I(인터페이스)-->B(USER) (A는 B에게 인터페이스만 보여줌-선언부분만, 중요한 부분은 안보여주기위해서)
			 
			-JDK1.8 기억안해도됨
			 :람다식,인터페이스의 개념 변경(인터페이스 다중상속 안됨, 클래스메서드,디폴트메서드가 구현 가능)
			 
		18. 내부클래스 inner class
			-내부클래스란?
			 : 클래스 내에 선언된 클래스
			 :서로 쉽게 접근할 수 있고 외부에서 볼때 불필요한 클래스를 감춤으로 복잡성을 줄일 수 있다. 
			-인스턴스 클래스
				: 외부클래스의 인스턴스 멤버들과 관련된 작업을 수행
			-스태틱클래스
				:외부클래스의 클래스멤버들과 관련된 작업을 수행, 클래스 메서드를 관련된 작업을 수행
			-지역클래스
				:외부클래스의 메서드나 초기화블럭 안에 선언, 선언 영역 내에서만 사용 가능
			-익명클래스
				:클래스의 선언과 객체의 생성을 동시에 진행한다.
				:이름이 없는 클래스(일회용)
		
		
		
		
		
		  
		  
		 */
		
		
		
		
		
	}
}
